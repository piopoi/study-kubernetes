# Chapter 01. 쿠버네티스 이해하기

- 쿠버네티스는 2014년 깃허브에서 오픈 소스로 처음 발표되었다.

## 쿠버네티스

쿠버네티스는 **컨테이너 오케스트레이션 도구**로 **컨테이너를 실행하는 플랫폼**이다.

- 가장 큰 장점은 **모든 애플리케이션을 모두 똑같은 방식으로 기술하고 배포하고 관리**할 수 있다는 것이다.
- 컨테이너 오케스트레이션: 다수의 컨테이너를 자동으로 배포, 관리, 스케일링, 네트워킹하는 과정.
  - 이를 통해 애플리케이션의 **가용성과 확장성을 보장**한다.

> [!NOTE]  
> 컨테이너(Container)는 **애플리케이션과 실행에 필요한 모든 요소(라이브러리, 종속성 등)을 하나의 패키지로 묶어 격리된 환경에서 실행할 수 있도록 하는 기술**이다.
> 컨테이너를 사용하면, 애플리케이션이 어떤 환경에서도 동일하게 실행될 수 있다는 장점이 있다.
> 컨테이너는 가상 머신(VM)과 비슷해 보이지만, 핵심적인 차이점은 **운영체제(OS) 커널을 공유**한다는 점이다.
> 즉, 가상머신처럼 별도의 OS를 포함하지 않고, **Host OS의 커널을 공유하면서도 독립적인 실행 환경을 제공**한다.
> 컨테이너 기술의 대표적인 구현체로 **Docker**가 있다.

- 제공하는 기능 예시
  - 컨테이너화된 애플리케이션의 시작.
  - 롤링 업데이트.
  - 서비스 수준 유지.
  - 수요에 따른 스케일링.
  - 보안 접근.
- 쿠버네티스의 두 가지 핵심 개념.
  1. 애플리케이션 정의에 사용되는 **API**.
  2. 애플리케이션이 실제로 동작하는 **클러스터(cluster)**.

## 쿠버네티스 클러스터

도커 같은 컨테이너 런타임이 동작하는(=**컨테이너를 실행할 수 있는**) **여러 대의 서버 노드로 구성된 하나의 논리적 단위**.

- 각 노드에서는 컨테이너 런타임이 실행된다.
- 노드 중 일부는 쿠버네티스 API를 실행하며, 나머지 노드는 컨테이너 속에서 동작하는 애플리케이션을 실행한다.
- 쿠버네티스 API는 리눅스 노드 상의 컨테이너에서 동작하지만, 클러스터 자체는 다른 플랫폼(윈도우 등)의 노드를 포함할 수 있다.
- 클러스터 관리자: 노드(node)라고 하는 각각의 서버를 관리한다.
  - 노드 추가, 노드 제거, 노드 업데이트 등.
- 쿠버네티스 매니지드 서비스 예: EKS(AWS), AKS(Azure).
- 일반적인 사용 시 각각의 노드를 신경 쓸 필요 없이 전체 클러스터를 하나의 대상처럼 다룰 수 있다.

## 쿠버네티스와 애플리케이션

쿠버네티스 클러스터의 목적은 **애플리케이션을 실행**하는 것으로, **도커 이미지**와 **쿠버네티스 YAML 파일**만 있으면 **모든 쿠버네티스 클러스터에서 동일하게 동작**하는 **자가수복형(self-healing) 애플리케이션**을 만들 수 있다.

- 쿠버네티스에서 애플리케이션을 실행하는 방법.
  1. YAML 파일에 애플리케이션의 구성을 기술하고, 이 파일을 쿠버네티스 API에 전달.
  2. 쿠버네티스가 파일에 기술된 애플리케이션 구성을 이해하고, 클러스터의 현재 상태와 비교.
  3. 파일에 기술된 것과 현재 상태에 차이가 있다면, 컨테이너를 추가 또는 제거.
- 명령행 도구 등으로 원격에서 쿠버네티스 API를 통해 애플리케이션을 관리할 수 있다.
- 쿠버네티스 **애플리케이션은 컨테이너에서 실행**된다.
  - 한 컴포넌트를 여러 컨테이너에서 여러 번 실행하여 스케일링을 구현하고 가용성을 확보할 수 있다.
  - 쿠버네티스 자체의 구성 요소 역시 리눅스 컨테이너 형태로 실행된다.
- **컨테이너**는 클러스터를 구성하는 **여러 노드에 흩어져 실행**된다.
  - 서로 다른 노드에 있는 컨테이너라도, 쿠버네티스가 관리하는 가상 네트워크로 서로 표준적인 네트워크 방식의 통신이 가능하다.
- 애플리케이션 구성을 파일에 기술하기만 하면, 그 구성을 따라 쿠버네티스가 애플리케이션을 실행하고 관리해준다.
  - 예시
    - 어떤 노드가 고장남 -> 해당 노드에서 실행되던 컨테이너를 다른 노드에서 실행된 컨테이너로 대체.
    - 특정 컨테이너에서 이상 발생 -> 해당 컨테이너 재시작.
    - 애플리케이션의 컴포넌트 중 하나의 부하가 높아짐 -> 해당 컴포넌트의 컨테이너를 추가로 실행.
- **애플리케이션 매니페스트(application manifest)**: 애플리케이션을 기술한 YAML 파일 명칭.
  - 파일 내용이 애플리케이션을 구성하는 모든 컴포넌트의 목록이기 때문에 이런 이름이 붙었다.
  - 애플리케이션을 구성하는 컴포넌트 = **리소스(resource)**

## 쿠버네티스가 완전한 애플리케이션 플랫폼이 될 수 있었던 몇 가지 이유

쿠버네티스가 관리하는 것은 컨테이너뿐만이 아니다. 바로 이 점 덕분에 쿠버네티스가 완전한 애플리케이션 플랫폼이 될 수 있었다.

### 분산 데이터베이스 in 클러스터

쿠버네티스는 **애플리케이션 구성 정보를 저장**할 수 있다.

- 클러스터에는 **분산 데이터베이스(etcd)**가 포함되어 있다.
  - 이 분산 DB에는 애플리케이션 구성 정보, API 키, 데이터베이스 접속 정보 등의 비밀값도 함께 저장할 수 있다.
- 클러스터의 모든 설정과 상태를 저장한다.
  - 모든 노드가 동일한 데이터를 공유하며, 클러스터의 안정성과 확정성을 유지한다.
- 이 정보들은 컨테이너 환경의 일부처럼 자연스럽게 컨테이너에게 제공된다.
- 클러스터에 정확한 설정이 들어 있다면, 어떤 환경이라도 동일한 컨테이너 이미지를 사용할 수 있다.

#### etcd

**분산형 Key-Value 저장소**로, 분산 시스템에서 중요한 데이터의 일관성과 신뢰성을 보장하기 위해 사용되는 쿠버네티스의 핵심 구성 요소다.

- 쿠버네티스에서 `kubectl get` 명령을 실행하면, 실제로는 etcd에 저장된 데이터를 API 서버가 조회하는 방식이다.
- 주요 특징
  - Raft 합의 알고리즘을 사용해 강력한 일관성(Consistency) 보장.
  - 노드 장애 시에도 데이터를 안전하게 유지하며, 자동으로 리더 선출.
- etcd가 쿠버네티스에서 하는 역할

  - 클러스터 상태 저장: 노드, 파드, 서비스, 네트워크 설정 등
  - 고가용성 보장: 다중 노드 배포 시 자동 복구 및 장애 감내
  - 컨트롤 플레인 데이터 관리: API 서버와 통신하여 최신 상태 유지

    > [!NOTE]  
    > 컨트롤 플레인은 쿠버네티스 클러스터의 중앙 관리 구성 요소로 클러스터의 상태를 모니터링하고 조정하는 역할을 하며, 컨트롤 플레인 데이터는 쿠버네티스 클러스터의 상태와 동작을 관리하는 데 필요한 데이터를 말한다. 컨트롤 플레인 데이터에는 클러스터의 노드 상태, 파드(Pod)의 상태와 배치 정보, 서비스와 네트워크 설정, 클러스터의 구성 정보와 정책 등이 있다.

### 스토리지 in 쿠버네티스

쿠버네티스는 스토리지를 제공할 수 있다.

- 스토리지를 이용하여 **컨테이너 외부에 데이터를 저장**할 수 있다.
- **유상태** 애플리케이션의 **고가용성을 확보**할 수 있다.
- 스토리지는 **클러스터 노드상의 디스크**에 저장되거나 **공유 스토리지**에 저장된다.

### 요청 감시 및 트래픽 관리

- 클러스터는 쿠버네티스 API로 들어오는 요청과 애플리케이션 요청을 모두 감시한다.
  - 애플리케이션 요청은 해당 요청을 처리할 컨테이너로 전달된다.
- 클러스터로 들어오는 크래픽을 관리한다.
